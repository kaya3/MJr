# MJr-compiler implementation notes

These notes explain some of the design and implementation details of the MJr-compiler project, which may be of interest to potential contributors, people developing similar projects, or anyone who is curious.

## Pipeline

The compiler works in several stages, using multiple intermediate representations:

- The [tokenizer](tokenizer.md) converts raw MJr source code into a sequence of tokens.
- The [parser](parser.md) converts this sequence of tokens into an abstract syntax tree (AST).
- The [resolver](resolver.md) converts the AST into an abstract semantic graph (ASG) and performs static checks.
- A [control-flow graph](cfg.md) (CFG) is built from the ASG.
- The [compiler](compiler.md) itself converts the ASG and CFG into a high-level [intermediate representation](ir.md) (IR) for the output code.
- The final output is then generated by the [code generator](codegen.md) for the target language.


## Next steps

Several features of the MJr programming language are not yet supported:

- `convchain`, `map` and `path` statements
- `convolution` statements and `sum` expressions
- `load` expressions
- `field` and `observe` rules
- Search
- Periodic grids

Additionally, there some features of the MarkovJunior programming language which are not yet included:

- 3D grids
- [Wave Function Collapse](https://github.com/mxgmn/WaveFunctionCollapse) statements

Some of these features need some more thought to the language design before they are implemented. See also the project's [GitHub issue tracker](https://github.com/kaya3/MJr/issues).
